Mapvapply(c, x = 1:10, y=letters[1:10], z = 1:10)
Mapvapply(c, x = 1:10, y=letters[1:10], z = 1:4)
Mapvapply(c, x = 1:10, y=letters[1:10], z = 1:9)
MapFun
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
lengths <- vapply(arglist, length, integer(1))
stopifnot(all(lengths == mean(lengths)))
MapFun <- function(x,y) {
Map(FUN, x, y)
}
vapply(arglist, vapply(arglist, MapFun, return.value),
vector(lengths[1]))
}
Mapvapply(c, return.value=numeric(3), x = 1:10, y=letters[1:10], z = 1:9)
Mapvapply(c, return.value=numeric(3), x = 1:10, y=letters[1:10], z = 1:10)
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
lengths <- vapply(arglist, length, integer(1))
stopifnot(all(lengths == mean(lengths)))
vapply(arglist, vapply(arglist, FUN, return.value),
vector(lengths[1]))
}
Mapvapply(c, return.value=numeric(3), x = 1:10, y=letters[1:10], z = 1:10)
Mapvapply(c, return.value=numeric(10), x = 1:10, y=letters[1:10], z = 1:10)
Mapvapply(c, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
lengths <- vapply(arglist, length, integer(1))
stopifnot(all(lengths == mean(lengths)))
vapply(arglist, function(x) vapply(x, FUN, return.value),
vector(lengths[1]))
}
Mapvapply(c, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
numeric(10)
mcMap
Mapvapply <- function(FUN, return.value = logical(0), ...){
vapply(list(...),
function(x) mcMap(FUN, x), return.value)
}
Mapvapply(sum, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
vapply(arglist,
function(x) mcMap(FUN, x, SIMPLIFY = T), return.value)
}
Mapvapply(sum, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
mcMap
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
vapply(arglist,
function(x) unlist(mcMap(FUN, x)), return.value)
}
Mapvapply(sum, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
Mapvapply(function(a) (a + 4)/5, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
Mapvapply <- function(FUN, return.value = logical(0), ...){
arglist <- list(...)
vapply(arglist,
function(x) unlist(mcMap(FUN, list(...))), return.value)
}
Mapvapply(function(a) (a + 4)/5, return.value=numeric(10), x = 1:10, y=11:20, z = 1:10)
Mapvapply(function(a) (a + 4)/5, return.value=numeric(30), x = 1:10, y=11:20, z = 1:10)
Mapvapply(sum, return.value=numeric(30), x = 1:10, y=11:20, z = 1:10)
Mapvapply(sum, return.value=numeric(3), x = 1:10, y=11:20, z = 1:10)
sum(11:20)
mcmapply
help(mcMap)
mcsapply <- function(x, FUN) {
mcMap(FUN, x)
}
mcsapply(mtcars, mean)
mcsapply <- function(x, FUN) {
unlist(mcMap(FUN, x))
}
mcsapply(mtcars, mean)
mcsapply <- function(x, FUN) {
unlist(mclapply(x, FUN))
}
mcsapply(mtcars, mean)
logical()
mcvapply <- function(x, FUN, output=logical(0)) {
out = unlist(mclapply(x, FUN))
stopifnot(
all(unlist(mclapply(out, class)) == class(output)) &
all(unlist(mclapply(out, length))== length(output))
)
out
}
mcvapply(mtcars, mean, output=numeric(1))
mcvapply(mtcars, range, output=numeric(2))
mcsapply(mtcars, range)
numeric(2)
mcvapply <- function(x, FUN, output=logical(0)) {
out = unlist(mclapply(x, FUN))
stopifnot(
all(mclapply(out, class)) == class(output)) &
all(mclapply(out, length))== length(output))
)
out
}
mcvapply(mtcars, range, output=numeric(2))
mcvapply <- function(x, FUN, output=logical(0)) {
out = unlist(mclapply(x, FUN))
stopifnot(
all(mclapply(out, class) == class(output)) &
all(mclapply(out, length) == length(output))
)
out
}
mcvapply(mtcars, range, output=numeric(2))
mcvapply <- function(x, FUN, output=logical(0)) {
out = unlist(mclapply(x, FUN))
stopifnot(
all(mclapply(out, class) == class(output)) &
all(mclapply(out, length) == length(output))
)
out
}
mcvapply(mtcars, range, output=numeric(2))
x
out
x <- matrix(rnorm(20, 0, 10), nrow = 4)
x
x1 <- sweep(x, 1, apply(x, 1, min))
x1
x2 <- sweep(x1, 1, apply(x1, 1, max), "/")
x2
outer(1:4, 2:8, '*')
outer(1:4, 2:8, sweep)
outer(1:4, 2:8, min)
outer(1:4, 2:8, pmin)
outer(1:4, 2:8, pmax)
rep(c(0, 5), c(10, 12)
)
rnorm(22, 70, 10 / 3)
pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
tapply(pulse, group, length)
tapply(pulse, group, mean)
split(pulse, group)
tapply2 <- function(x, group, fun, ..., simplify = TRUE){
pieces <- split(x, group)
sapply(pieces, fun, ..., simplify=simplify)
}
tapply2(pulse, group, mean)
tapply2(pulse, group, sd)
split2 <- function(x, group, ...){
out <- list()
for(e in unique(group)){
out[[e]] <- x[group == e]
}
}
split2(pulse, group)
split2 <- function(x, group, ...){
out <- list()
for(e in unique(group)){
out[[e]] <- x[group == e]
}
out
}
split2(pulse, group)
d <- data(Titanic)
data(Titanic)
d <- Titanic
d <- read.csv('~/projects/rcharts_plugins/parallelsets/titanic.csv')
View(d)
d <- as.data.frame(table(d))
View(d)
names(d)<- tolower(names(d))
names(d)[5] <- "count"
write.csv('~/projects/rcharts_plugins/parallelsets/titanic_agg.csv', rownames=F)
write.csv('~/projects/rcharts_plugins/parallelsets/titanic_agg.csv', row.names=F)
write.csv(d, '~/projects/rcharts_plugins/parallelsets/titanic_agg.csv', row.names=F)
help(apply)
apply
View(d)
split2 <- function(x, group, ...){
out <- list()
for(e in unique(group)){
out[[e]] <- x[group == e]
}
out
}
split2(pulse, group)
pulse <- round(rnorm(22, 70, 10 / 3)) + rep(c(0, 5), c(10, 12))
group <- rep(c("A", "B"), c(10, 12))
tapply(pulse, group, length)
tapply(pulse, group, mean)
split(pulse, group)
# so...
tapply2 <- function(x, group, fun, ..., simplify = TRUE){
pieces <- split(x, group)
sapply(pieces, fun, ..., simplify=simplify)
}
tapply2(pulse, group, sd)
rm(Titanic)
Reduce
Reduce('+', c(1,2,3))
Reduce('+', 1,2,3)
Reduce('+', 1:10)
Reduce('+', 1:10, rright=T)
Reduce('+', 1:10, right=T)
l <- replicate(5, sample(1:10, 15, replace = T), simplify = F)
Reduce(intersect, l)
where(is.factor, iris)
where <- function(f, x) {
vapply(x, f, logical(1))
}
where(is.factor, iris)
Filter(is.factor, iris)
## returns a data frame - does not simplify
str(Filter(is.factor, iris)) ## returns a data frame - does not simplify
Find(is.factor, iris)
Position(is.factor, iris)
compact <- function(x) Filter(function(y) !is.null(y), x)
integrate(sin, 0, pi)
str(uniroot(sin, pi * (1/3 , 2/3)))
str(uniroot(sin, pi * (1/3 , 3/2)))
str(uniroot(sin, pi * c(1/3 , 3/2)))
uniroot(sin, pi * c(1/3 , 3/2))
str(optimise(sin, pi * c(0, 2 * pi)))
str(optimise(sin, pi * c(0, 2 * pi)))
str(optimise(sin, c(0, 2 * pi)))
str(optimise(sin, c(0, pi), maximize = TRUE))
str(optimise(sin, c(0, pi)), maximize = TRUE)
str(optimise(sin, c(0, pi), maximize = TRUE))
str(optimise(sin, c(0, pi), maximum = TRUE))
arg_max <- function(fun, x) {
res <- vapply(x, fun, numeric(1))
x[res==max(res)]
}
arg_max(function(x) x^2, -10:4)
arg_max(function(x) x^2, -5:5)
data.frame(x = 1:10, y = 1:7)
1:10 * c(3,5)
xor
paste
paste("a", "few", "strings")
paste("a", "few", "strings", collapse="+")
paste(c("a", "couple", "few", "er", "sumphin"), "few", "strings", collapse="+")
library(parallel)
chatty <- function(f) {
function(x, ...) {
res <- f(x, ...)
cat("Processing ", x, "\n", sep = "")
res
}
}
lapply(s, chatty)
s <- c(1,2,3)
lapply(s, chatty(sys.sleep))
lapply(s, chatty(Sys.sleep))
mclapply(s, chatty(Sys.sleep))
install.packages('memoise')
library(memoise)
library(pryr)
library(plyr)
delay
delay_by <- function(delay, f, ...){
function(...) {
Sys.time(delay)
f(...)
}
}
delay_by(2, sum(2,3))
delay_by(2, sum)(2,3)
delay_by <- function(delay, f){
function(...) {
Sys.sleep(delay)
f(...)
}
}
delay_by(2, sum)(2,3)
cat('.')
dot_every <- function(n, f){
i <- 1
function(...){
if i %% n == 0 cat('.')
i <<- i + 1
f(...)
}
}
dot_every <- function(n, f){
i <- 1
function(...){
if (i %% n == 0) cat('.')
i <<- i + 1
f(...)
}
}
x <- lapply(1:100, runif)
x <- lapply(1:100, dot_every(10, runif))
install.packages('rpostgresql')
install.packages('RPostgreSQL')
library('RPostgreSQL')
library(RPostgreSQL)
library(rCharts)
library(ggplot2)
library(plyr)
library(reshape2)
library(lubridate)
con <- dbConnect(PostgreSQL(), user="ben", password="fender",dbname="disqus")
rs <- dbSendQuery(con,"show tables;")
con <- dbConnect(PostgreSQL(), user="ben", password="fender",dbname="disqus")
rs <- dbSendQuery(con,"show tables;")
rs <- dbSendQuery(con,"select user_id_anonymized from disqus_posts limit 10;")
out <- fetch(rs)
out
rs <- dbSendQuery(con,"select * from disqus_posts limit 10;")
out <- fetch(rs)
rs <- dbSendQuery(con,"select * from disqus_posts limit 10;")
head_posts <- fetch(rs)
rm(out)
rs <- dbSendQuery(con, "select * from disqus_threads limit 10")
head_thread <- fetch(rs)
View(head_thread)
View(head_posts)
d <- read.delim2('/home/ben/projects/disqus/candidate/posts.tsv')
names(d)
names(d) <- names(head_posts)
head(d)
rm(d)
View(head_posts)
24*60
24*60*3
library(plyr)
library(rCharts)
library(stringr)
library(doMC)
library(iterators)
library(foreach)
registerDoMC(4)
d <- read.csv('~/projects/rcharts_plugins/sequence_sunburst/data//visit-sequences.csv', header = FALSE)
names(d) <- c('path' ,'count')
d$path <- gsub('-', '~', d$path)
head(d)
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'id', count_var='count',
percentageText = "users who had the highlighted path")
str(sun)
cat(sun$templates$script)
search()
detach(15)
source('~/projects/rcharts_plugins/plugins.R', echo=TRUE)
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'id', count_var='count',
percentageText = "users who had the highlighted path")
sun$LIB
sun
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'id', count_var='count',
percentageText = "users who had the highlighted path")
sun$LIB
sun
toJSONArray(d[1:5,])
detach()
source('~/projects/rcharts_plugins/plugins.R', echo=TRUE)
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'id', count_var='count',
percentageText = "users who had the highlighted path")
sun$LIB
sun
detach()
source('~/projects/rcharts_plugins/plugins.R', echo=TRUE)
detach()
source('~/projects/rcharts_plugins/plugins.R', echo=TRUE)
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'id', count_var='count',
percentageText = "users who had the highlighted path")
sun <- SeqSunburst$new()
sun$set(data = d, id_var = 'path', count_var='count',
percentageText = "users who had the highlighted path")
sun$LIB
sun
length(unique(d$path))
write.csv(d, '~/projects/rcharts_plugins/sequence_sunburst/data//visit-sequences.csv', row.names=FALSE)
write.csv(d, '~/projects/rcharts_plugins/sequence_sunburst/data//visit-sequences.csv', row.names=FALSE, header = FALSE)
help(write.csv)
write.csv(d, '~/projects/rcharts_plugins/sequence_sunburst/data//visit-sequences.csv', row.names=FALSE, col.names = FALSE)
write.table(d, '~/projects/rcharts_plugins/sequence_sunburst/data//visit-sequences.csv', row.names=FALSE, col.names = FALSE, sep = ',')
hist
ggplot(data.frame(x = rnorm(100)), aes(x=x)) + geom_boxplot()
library(ggplot)
library(ggplot2)
hist(data.frame(x = rnorm(100))
)
hist(data.frame(x = rnorm(100)$x))
ggplot(data.frame(x = rnorm(100)), aes(x=x)) + geom_boxplot()
ggplot(data.frame(x = rnorm(100)), aes(y=x)) + geom_boxplot()
ggplot(data.frame(x = rnorm(100), y = 'one'), aes(y=x, x=y)) + geom_boxplot()
ggplot(data.frame(x = rnorm(100), y = 'one'), aes(y=x, x=y)) + geom_boxplot() + coord_flip()
ggplot(data.frame(x = rnorm(100), y = 'one'), aes(y=x, x=y)) + geom_boxplot() + coord_flip() + geom_jitter()
ggplot(data.frame(x = rnorm(100), y = 'one'), aes(y=x, x=y, color=y)) + geom_boxplot() + coord_flip() + geom_jitter()
library(foreign)
library(RJSONIO)
polls <- read.dta('~/Dropbox/HLM/ARM_Data/election88/polls.dta')
make_factors <- function(d, min = 20) {
facs <- which(sapply(d, function(x) length(unique(x)) < min))
d[facs] <- lapply(d[facs], factor)
d
}
polls <- make_factors(polls)
polls <- polls[complete.cases(polls),]
polls$state <- factor(polls$state)
formulas <- list(m1='bush ~ black + female',
m2 = "bush ~ black + female + edu + age",
m3 = "bush ~ black + female + edu + age + year")
models <- lapply(formulas, glm, data = polls, family = binomial)
coefs <- lapply(models, function(x) {
cf <- as.data.frame(summary(x)$coef)
cf$variables <- row.names(cf)})
fits <- as.data.frame(lapply(models, fitted))
names(fits) <- paste0('fit_', names(fits))
polls <- cbind(polls, fits)
rm(fits)
res <- as.data.frame(lapply(models, resid))
names(res) <- paste0('resid_', names(res))
polls <- cbind(polls, res)
rm(res)
View(polls)
ggplot2
ggplot
ggplot(polls, aes(x = fit_m1, y = resid_m1)) + geom_point()
ggplot(polls, aes(x = fit_m2, y = resid_m2)) + geom_point()
ggplot(polls, aes(x = fit_m3, y = resid_m3)) + geom_point()
models <- lapply(formulas, glm, data = polls, family = binomial,
weights = polls$weight)
models <- lapply(formulas, glm, data = polls, family = binomial,
weight = polls$weight)
help(glm)
models <- lapply(formulas, function(x) {
glm(x, data = polls, family = binomial, weights = polls$weight)
})
coefs <- lapply(models, function(x) {
cf <- as.data.frame(summary(x)$coef)
cf$variables <- row.names(cf)})
fits <- as.data.frame(lapply(models, fitted))
names(fits) <- paste0('fit_', names(fits))
polls <- cbind(polls, fits)
rm(fits)
res <- as.data.frame(lapply(models, resid))
names(res) <- paste0('resid_', names(res))
polls <- cbind(polls, res)
rm(res)
ch <- PlotLM$new()
ch$set(data = polls[sample(nrow(polls), 1000),], coefs = coefs, width=700, height=700,
formulas = formulas, prediction_lines = 3
)
# str(ch)
ch
setwd('~/projects/rcharts_plugins/)
setwd('~/projects/rcharts_plugins/')
setwd('~/projects/rcharts_plugins/')
ch <- PlotLM$new()
ch$set(data = polls[sample(nrow(polls), 1000),], coefs = coefs, width=700, height=700,
formulas = formulas, prediction_lines = 3
)
# str(ch)
ch
coefs
coefs <- lapply(models, function(x) {
cf <- as.data.frame(summary(x)$coef)
cf$variables <- row.names(cf)
cf
})
ch <- PlotLM$new()
ch$set(data = polls[sample(nrow(polls), 1000),], coefs = coefs, width=700, height=700,
formulas = formulas, prediction_lines = 3
)
# str(ch)
ch
coefs
coefs <- lapply(models, function(x) {
cf <- as.data.frame(summary(x)$coef)
cf$variable <- row.names(cf)
cf
})
ch <- PlotLM$new()
ch$set(data = polls[sample(nrow(polls), 1000),], coefs = coefs, width=700, height=700,
formulas = formulas, prediction_lines = 3
)
# str(ch)
ch
models <- lapply(formulas, function(x) {
glm(x, data = polls, family = binomial)
})
coefs <- lapply(models, function(x) {
cf <- as.data.frame(summary(x)$coef)
cf$variable <- row.names(cf)
cf
})
fits <- as.data.frame(lapply(models, fitted))
names(fits) <- paste0('fit_', names(fits))
polls <- cbind(polls, fits)
rm(fits)
res <- as.data.frame(lapply(models, resid))
names(res) <- paste0('resid_', names(res))
polls <- cbind(polls, res)
rm(res)
setwd('~/projects/rcharts_plugins/')
ch <- PlotLM$new()
ch$set(data = polls[sample(nrow(polls), 1000),], coefs = coefs, width=700, height=700,
formulas = formulas, prediction_lines = 3
)
# str(ch)
ch
cat(RJSONIO::toJSON(coefs))
cat(RJSONIO::toJSON(formulas))
write.csv(polls, "~/projects/rcharts_plugins/plot_glmer/data/polls.csv", row.names=FALSE)
cat(RJSONIO::toJSON(sapply(polls, class)))
write.csv(polls[sample(nrow(polls), 1000), ], "~/projects/rcharts_plugins/plot_glmer/data/polls.csv", row.names=FALSE)
bills( 181.12)
